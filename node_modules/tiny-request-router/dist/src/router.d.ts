import { Key as TokenKey, pathToRegexp, TokensToRegexpOptions } from 'path-to-regexp';
export { pathToRegexp };
/** Valid HTTP methods for matching. */
export declare type Method = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'HEAD' | 'OPTIONS';
export declare type MethodWildcard = 'ALL';
export interface Params {
    [key: string]: string;
}
/**
 * Optional route options.
 *
 * @example
 * // When `true` the regexp will be case sensitive. (default: `false`)
 * sensitive?: boolean;
 *
 * // When `true` the regexp allows an optional trailing delimiter to match. (default: `false`)
 * strict?: boolean;
 *
 * // When `true` the regexp will match to the end of the string. (default: `true`)
 * end?: boolean;
 *
 * // When `true` the regexp will match from the beginning of the string. (default: `true`)
 * start?: boolean;
 *
 * // Sets the final character for non-ending optimistic matches. (default: `/`)
 * delimiter?: string;
 *
 * // List of characters that can also be "end" characters.
 * endsWith?: string;
 *
 * // Encode path tokens for use in the `RegExp`.
 * encode?: (value: string) => string;
 */
export interface RouteOptions extends TokensToRegexpOptions {
}
export interface Route<HandlerType> {
    method: Method | MethodWildcard;
    path: string;
    regexp: RegExp;
    options: RouteOptions;
    keys: Keys;
    handler: HandlerType;
}
/**
 * The object returned when a route matches.
 *
 * The handler can then be used to execute the relevant function.
 *
 * @example
 * {
 *   params: Params
 *   matches?: RegExpExecArray
 *   method: Method | MethodWildcard
 *   path: string
 *   regexp: RegExp
 *   options: RouteOptions
 *   keys: Keys
 *   handler: HandlerType
 * }
 */
export interface RouteMatch<HandlerType> extends Route<HandlerType> {
    params: Params;
    matches?: RegExpExecArray;
}
export declare type Key = TokenKey;
export declare type Keys = Array<Key>;
/**
 * Tiny request router. Allows overloading of handler type to be fully type safe.
 *
 * @example
 * import { Router, Method, Params } from 'tiny-request-router'
 *
 * // Let the router know that handlers are async functions returning a Response
 * type Handler = (params: Params) => Promise<Response>
 *
 * const router = new Router<Handler>()
 */
export declare class Router<HandlerType = any> {
    /** List of all registered routes. */
    routes: Array<Route<HandlerType>>;
    /** Add a route that matches any method. */
    all(path: string, handler: HandlerType, options?: RouteOptions): this;
    /** Add a route that matches the GET method. */
    get(path: string, handler: HandlerType, options?: RouteOptions): this;
    /** Add a route that matches the POST method. */
    post(path: string, handler: HandlerType, options?: RouteOptions): this;
    /** Add a route that matches the PUT method. */
    put(path: string, handler: HandlerType, options?: RouteOptions): this;
    /** Add a route that matches the PATCH method. */
    patch(path: string, handler: HandlerType, options?: RouteOptions): this;
    /** Add a route that matches the DELETE method. */
    delete(path: string, handler: HandlerType, options?: RouteOptions): this;
    /** Add a route that matches the HEAD method. */
    head(path: string, handler: HandlerType, options?: RouteOptions): this;
    /** Add a route that matches the OPTIONS method. */
    options(path: string, handler: HandlerType, options?: RouteOptions): this;
    /**
     * Match the provided method and path against the list of registered routes.
     *
     * @example
     * router.get('/foobar', async () => new Response('Hello'))
     *
     * const match = router.match('GET', '/foobar')
     * if (match) {
     *   // Call the async function of that match
     *   const response = await match.handler()
     *   console.log(response) // => Response('Hello')
     * }
     */
    match(method: Method, path: string): RouteMatch<HandlerType> | null;
    private _push;
}
